# main.py

import os
import threading
import re
import requests
import pandas as pd
import csv
from datetime import datetime, timezone
from io import StringIO, BytesIO

from flask import Flask
from telegram import Update, ReplyKeyboardMarkup, KeyboardButton
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
)

from config import TOKEN, SELF_URL, PORT, ZONES_CSV_URL, BRANCH_URLS, NOTIFY_URLS
from zones import normalize_sheet_url, load_zones

# Flask & Bot setup
app = Flask(__name__)
application = ApplicationBuilder().token(TOKEN).build()

# –õ–æ–≥ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
LOG_NOTIFY_FILE = os.getenv("NOTIFY_LOG_FILE", "notifications_log.csv")
if not os.path.exists(LOG_NOTIFY_FILE):
    with open(LOG_NOTIFY_FILE, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow([
            "Filial", "–†–≠–°",
            "SenderID", "SenderName",
            "RecipientID", "RecipientName",
            "Timestamp", "Coordinates"
        ])

# –°—ã—Ä—ã–µ –∏–º–µ–Ω–∞ —Ñ–∏–ª–∏–∞–ª–æ–≤ ‚Üí –∫–ª—é—á–∏ BRANCH_URLS
BRANCH_KEY_MAP = {
    "–¢–∏–º–∞—à–µ–≤—Å–∫–∏–π":      "–¢–∏–º–∞—à–µ–≤—Å–∫–∏–µ –≠–°",
    "–£—Å—Ç—å-–õ–∞–±–∏–Ω—Å–∫–∏–π":   "–£—Å—Ç—å-–õ–∞–±–∏–Ω—Å–∫–∏–µ –≠–°",
    "–¢–∏—Ö–æ—Ä–µ—Ü–∫–∏–π":       "–¢–∏—Ö–æ—Ä–µ—Ü–∫–∏–µ –≠–°",
    "–°–æ—á–∏–Ω—Å–∫–∏–π":        "–°–æ—á–∏–Ω—Å–∫–∏–µ –≠–°",
    "–°–ª–∞–≤—è–Ω—Å–∫–∏–π":       "–°–ª–∞–≤—è–Ω—Å–∫–∏–µ –≠–°",
    "–õ–µ–Ω–∏–Ω–≥—Ä–∞–¥—Å–∫–∏–π":    "–õ–µ–Ω–∏–Ω–≥—Ä–∞–¥—Å–∫–∏–µ –≠–°",
    "–õ–∞–±–∏–Ω—Å–∫–∏–π":        "–õ–∞–±–∏–Ω—Å–∫–∏–µ –≠–°",
    "–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π":    "–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–µ –≠–°",
    "–ê—Ä–º–∞–≤–∏—Ä—Å–∫–∏–π":      "–ê—Ä–º–∞–≤–∏—Ä—Å–∫–∏–µ –≠–°",
    "–ê–¥—ã–≥–µ–π—Å–∫–∏–π":       "–ê–¥—ã–≥–µ–π—Å–∫–∏–µ –≠–°",
    "–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π":      "–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–µ –≠–°",
    "–ó–∞–ø–∞–¥–Ω—ã–π":         "–ó–∞–ø–∞–¥–Ω—ã–µ –≠–°",
    "–í–æ—Å—Ç–æ—á–Ω—ã–π":        "–í–æ—Å—Ç–æ—á–Ω—ã–µ –≠–°",
    "–Æ–∂–Ω—ã–π":            "–Æ–∂–Ω—ã–µ –≠–°",
    "–°–µ–≤–µ—Ä–æ-–í–æ—Å—Ç–æ—á–Ω—ã–π": "–°–µ–≤–µ—Ä–æ-–í–æ—Å—Ç–æ—á–Ω—ã–µ –≠–°",
    "–Æ–≥–æ-–í–æ—Å—Ç–æ—á–Ω—ã–π":    "–Æ–≥–æ-–í–æ—Å—Ç–æ—á–Ω—ã–µ –≠–°",
    "–°–µ–≤–µ—Ä–Ω—ã–π":         "–°–µ–≤–µ—Ä–Ω—ã–µ –≠–°",
}

# –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã
kb_back = ReplyKeyboardMarkup([["üîô –ù–∞–∑–∞–¥"]], resize_keyboard=True)
kb_report = ReplyKeyboardMarkup(
    [
        ["üìä –í—ã–≥—Ä—É–∑–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è"],
        ["üìã –í—ã–≥—Ä—É–∑–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –ø–æ –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç–∞–º"],
        ["üîô –ù–∞–∑–∞–¥"],
    ],
    resize_keyboard=True
)

def build_initial_kb(vis_flag: str) -> ReplyKeyboardMarkup:
    flag = vis_flag.strip().upper()
    if flag == "ALL":
        nets = ["‚ö° –†–æ—Å—Å–µ—Ç–∏ –Æ–ì", "‚ö° –†–æ—Å—Å–µ—Ç–∏ –ö—É–±–∞–Ω—å"]
    elif flag == "UG":
        nets = ["‚ö° –†–æ—Å—Å–µ—Ç–∏ –Æ–ì"]
    else:
        nets = ["‚ö° –†–æ—Å—Å–µ—Ç–∏ –ö—É–±–∞–Ω—å"]
    buttons = [[n] for n in nets] + [
        ["üìû –¢–µ–ª–µ—Ñ–æ–Ω—ã –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤"],
        ["üìù –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –æ—Ç—á—ë—Ç"],
    ]
    return ReplyKeyboardMarkup(buttons, resize_keyboard=True)

def build_branch_kb(uid: int, selected_net: str, branch_map: dict) -> ReplyKeyboardMarkup:
    raw = branch_map.get(uid, "All")
    if raw != "All":
        branches = [raw]
    else:
        branches = list(BRANCH_URLS[selected_net].keys())
    btns = [[b] for b in branches] + [["üîô –ù–∞–∑–∞–¥"]]
    return ReplyKeyboardMarkup(btns, resize_keyboard=True)

kb_actions = ReplyKeyboardMarkup(
    [["üîç –ü–æ–∏—Å–∫ –ø–æ –¢–ü"], ["üîî –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ"], ["üîô –ù–∞–∑–∞–¥"]],
    resize_keyboard=True
)
kb_request_location = ReplyKeyboardMarkup(
    [[KeyboardButton("üìç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é", request_location=True)], ["üîô –ù–∞–∑–∞–¥"]],
    resize_keyboard=True
)

# /start
async def start_line(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    vis_map, raw_branch_map, res_map, names, resp_map = load_zones()

    branch_map = {
        u: ("All" if raw == "All" else BRANCH_KEY_MAP.get(raw, raw))
        for u, raw in raw_branch_map.items()
    }

    if uid not in branch_map:
        await update.message.reply_text("üö´ –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞.", reply_markup=kb_back)
        return

    context.user_data.clear()
    context.user_data.update({
        "step":        "INIT",
        "vis_flag":    vis_map[uid],
        "branch_user": branch_map[uid],
        "res_user":    res_map[uid],
        "resp_map":    resp_map,
        "name":        names[uid],
    })

    await update.message.reply_text(
        f"üëã –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤—É—é –í–∞—Å, {names[uid]}! –í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:",
        reply_markup=build_initial_kb(vis_map[uid])
    )

# –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # –µ—Å–ª–∏ /start –Ω–µ –≤—ã–∑—ã–≤–∞–ª–∏ ‚Äî –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ–º
    if "step" not in context.user_data:
        return await start_line(update, context)

    text = update.message.text.strip()
    uid  = update.effective_user.id

    vis_map, raw_branch_map, res_map, names, _ = load_zones()
    branch_map = {
        u: ("All" if raw == "All" else BRANCH_KEY_MAP.get(raw, raw))
        for u, raw in raw_branch_map.items()
    }

    if uid not in branch_map:
        await update.message.reply_text("üö´ –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞.", reply_markup=kb_back)
        return

    step        = context.user_data["step"]
    vis_flag    = context.user_data["vis_flag"]
    branch_user = context.user_data["branch_user"]
    res_user    = context.user_data["res_user"]
    resp_flag   = context.user_data["resp_map"].get(uid, "").strip()
    user_name   = context.user_data["name"]

    # –ù–∞–∑–∞–¥
    if text == "üîô –ù–∞–∑–∞–¥":
        if step in ("AWAIT_TP_INPUT","DISAMBIGUOUS",
                    "NOTIFY_AWAIT_TP","NOTIFY_DISAMBIGUOUS",
                    "NOTIFY_AWAIT_VL","NOTIFY_WAIT_GEO"):
            context.user_data["step"] = "BRANCH_SELECTED"
            await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=kb_actions)
            return
        if step == "NETWORK_SELECTED":
            context.user_data["step"] = "INIT"
            await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:", reply_markup=build_initial_kb(vis_flag))
            return
        if step == "REPORT_MENU":
            context.user_data["step"] = "INIT"
            await update.message.reply_text(
                f"üëã –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤—É—é –í–∞—Å, {user_name}! –í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:",
                reply_markup=build_initial_kb(vis_flag)
            )
            return
        context.user_data["step"] = "INIT"
        await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:", reply_markup=build_initial_kb(vis_flag))
        return

    # INIT
    if step == "INIT":
        if text == "üìû –¢–µ–ª–µ—Ñ–æ–Ω—ã –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤":
            context.user_data["step"] = "VIEW_PHONES"
            await update.message.reply_text("üìû –¢–µ–ª–µ—Ñ–æ–Ω—ã –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤:\n‚Ä¶", reply_markup=kb_back)
            return

        if text == "üìù –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –æ—Ç—á—ë—Ç":
            context.user_data["step"] = "REPORT_MENU"
            await update.message.reply_text("üìù –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –æ—Ç—á—ë—Ç–∞:", reply_markup=kb_report)
            return

        flag = vis_flag.strip().upper()
        allowed = (["‚ö° –†–æ—Å—Å–µ—Ç–∏ –Æ–ì","‚ö° –†–æ—Å—Å–µ—Ç–∏ –ö—É–±–∞–Ω—å"] if flag=="ALL"
                   else ["‚ö° –†–æ—Å—Å–µ—Ç–∏ –Æ–ì"] if flag=="UG"
                   else ["‚ö° –†–æ—Å—Å–µ—Ç–∏ –ö—É–±–∞–Ω—å"])
        if text in allowed:
            selected_net = text.replace("‚ö° ","")
            context.user_data.update({
                "step":         "NETWORK_SELECTED",
                "selected_net": selected_net
            })
            await update.message.reply_text(
                "–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∏–ª–∏–∞–ª:",
                reply_markup=build_branch_kb(uid, selected_net, branch_map)
            )
        else:
            await update.message.reply_text(
                f"{user_name}, –º–æ–∂–µ—Ç–µ –ø—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ: {', '.join(allowed)} üòï",
                reply_markup=build_initial_kb(vis_flag)
            )
        return

    # REPORT_MENU
    if step == "REPORT_MENU":
        if text == "üìä –í—ã–≥—Ä—É–∑–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è":
            df = pd.read_csv(LOG_NOTIFY_FILE)
            bio = BytesIO()
            with pd.ExcelWriter(bio, engine="openpyxl") as writer:
                df.to_excel(writer, index=False, sheet_name="Notifications")
                wb  = writer.book
                ws  = writer.sheets["Notifications"]
                from openpyxl.styles import PatternFill
                from openpyxl.utils import get_column_letter
                # pink header
                pink = PatternFill(start_color="FFF2DCDB", end_color="FFF2DCDB", fill_type="solid")
                for cell in ws[1]:
                    cell.fill = pink
                # auto-width
                for col in ws.columns:
                    max_length = max(len(str(c.value)) for c in col if c.value)
                    ws.column_dimensions[get_column_letter(col[0].column)].width = max_length + 2
            bio.seek(0)
            await update.message.reply_document(
                document=bio,
                filename="notifications_log.xlsx",
                caption="üìä –õ–æ–≥ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π (Excel)"
            )
            await update.message.reply_text("üìù –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –æ—Ç—á—ë—Ç–∞:", reply_markup=kb_report)
            return

        if text == "üìã –í—ã–≥—Ä—É–∑–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –ø–æ –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç–∞–º":
            await update.message.reply_text("üìã –°–ø—Ä–∞–≤–æ—á–Ω–∏–∫ –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç–æ–≤ ‚Äî —Å–∫–æ—Ä–æ –±—É–¥–µ—Ç!", reply_markup=kb_report)
            return

        return

    # NETWORK_SELECTED
    if step == "NETWORK_SELECTED":
        selected_net = context.user_data["selected_net"]
        allowed = [branch_user] if branch_user!="All" else list(BRANCH_URLS[selected_net].keys())
        if text in allowed:
            context.user_data.update({
                "step":           "BRANCH_SELECTED",
                "current_branch": text
            })
            await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=kb_actions)
        else:
            await update.message.reply_text(
                f"{user_name}, –º–æ–∂–µ—Ç–µ –ø—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ: {', '.join(allowed)} üòï",
                reply_markup=build_branch_kb(uid, selected_net, branch_map)
            )
        return

    # BRANCH_SELECTED
    if step == "BRANCH_SELECTED":
        if text == "üîç –ü–æ–∏—Å–∫ –ø–æ –¢–ü":
            context.user_data["step"] = "AWAIT_TP_INPUT"
            await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –¢–ü:", reply_markup=kb_back)
            return
        if text == "üîî –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ":
            if resp_flag:
                await update.message.reply_text(f"{user_name}, –Ω–µ –º–æ–∂–µ—Ç–µ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è üòï", reply_markup=kb_actions)
                return
            context.user_data["step"] = "NOTIFY_AWAIT_TP"
            await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –¢–ü –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:", reply_markup=kb_back)
            return
        return

    # AWAIT_TP_INPUT (—Å –æ—Ç–ª–∞–¥–∫–æ–π)
    if step == "AWAIT_TP_INPUT":
        selected_net   = context.user_data.get("selected_net")
        current_branch = context.user_data.get("current_branch")
        await update.message.reply_text(f"üîç DEBUG: Step={step}, net={selected_net}, branch={current_branch}")
        url = BRANCH_URLS[selected_net][current_branch]
        await update.message.reply_text(f"üîç DEBUG: Loading URL {url}")
        df = pd.read_csv(normalize_sheet_url(url))
        if res_user!="All":
            norm=lambda s:re.sub(r'\W','',str(s).upper())
            df = df[df["–†–≠–°"].apply(norm)==norm(res_user)]
        df.columns=df.columns.str.strip()
        df["D_UP"]=df["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"].str.upper().str.replace(r'\W','',regex=True)

        q=re.sub(r'\W','',text.upper())
        found=df[df["D_UP"].str.contains(q,na=False)]
        if found.empty:
            await update.message.reply_text("üîç –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö. –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ:", reply_markup=kb_back)
            return

        # –¥–∞–ª–µ–µ –∫–∞–∫ –æ–±—ã—á–Ω–æ‚Ä¶
        unique_tp=found["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"].unique().tolist()
        if len(unique_tp)>1:
            context.user_data.update({"step":"DISAMBIGUOUS","ambiguous_df":found})
            kb=ReplyKeyboardMarkup([[tp] for tp in unique_tp]+[["üîô –ù–∞–∑–∞–¥"]],resize_keyboard=True)
            await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –¢–ü:",reply_markup=kb)
            return

        tp_sel=unique_tp[0]
        details=found[found["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"]==tp_sel]
        cnt=len(details); rname=details.iloc[0]["–†–≠–°"]
        await update.message.reply_text(
            f"{rname}, {tp_sel} ({cnt}) –í–û–õ–° —Å –¥–æ–≥–æ–≤–æ—Ä–æ–º –∞—Ä–µ–Ω–¥—ã.\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
            reply_markup=kb_actions
        )
        for _,r in details.iterrows():
            await update.message.reply_text(
                f"üìç –í–õ {r['–£—Ä–æ–≤–µ–Ω—å –Ω–∞–ø—Ä—è–∂–µ–Ω–∏—è']} {r['–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –í–õ']}\n"
                f"–û–ø–æ—Ä—ã: {r['–û–ø–æ—Ä—ã']}\n"
                f"–ü—Ä–æ–≤–∞–π–¥–µ—Ä: {r.get('–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –ü—Ä–æ–≤–∞–π–¥–µ—Ä–∞','')}",
                reply_markup=kb_actions
            )
        context.user_data["step"]="BRANCH_SELECTED"
        return

    # NOTIFY_AWAIT_TP (—Å –æ—Ç–ª–∞–¥–∫–æ–π)
    if step == "NOTIFY_AWAIT_TP":
        current_branch = context.user_data.get("current_branch")
        await update.message.reply_text(f"üîî DEBUG: Notify step={step}, branch={current_branch}")
        sheet_url = NOTIFY_URLS.get(current_branch, "")
        await update.message.reply_text(f"üîî DEBUG: Notify URL {sheet_url}")
        dfn = pd.read_csv(normalize_sheet_url(sheet_url))
        dfn.columns = dfn.columns.str.strip()
        dfn["D_UP_TP"] = dfn["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"].str.upper().str.replace(r"\W","",regex=True)
        # –¥–∞–ª–µ–µ –∫–∞–∫ –æ–±—ã—á–Ω–æ‚Ä¶
        q = re.sub(r"\W","",text.upper())
        found = dfn[dfn["D_UP_TP"].str.contains(q,na=False)]
        if found.empty:
            await update.message.reply_text("üîî –ù–µ –Ω–∞–π–¥–µ–Ω–æ –¢–ü. –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ:",reply_markup=kb_back)
            return
        ulist = found["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"].unique().tolist()
        if len(ulist)>1:
            context.user_data.update({"step":"NOTIFY_DISAMBIGUOUS","notify_df":found})
            kb = ReplyKeyboardMarkup([[tp] for tp in ulist]+[["üîô –ù–∞–∑–∞–¥"]],resize_keyboard=True)
            await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –¢–ü –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:",reply_markup=kb)
            return
        tp_sel = ulist[0]
        context.user_data["notify_tp"] = tp_sel
        df_tp = found[found["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"]==tp_sel]
        context.user_data["notify_df"] = df_tp
        vls = df_tp["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –í–õ"].unique().tolist()
        context.user_data["step"] = "NOTIFY_AWAIT_VL"
        kb = ReplyKeyboardMarkup([[vl] for vl in vls]+[["üîô –ù–∞–∑–∞–¥"]],resize_keyboard=True)
        await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –í–õ –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:",reply_markup=kb)
        return

    # ‚Ä¶ –æ—Å—Ç–∞–ª—å–Ω—ã–µ —à–∞–≥–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –∏ geo handler ‚Ä¶

# –ì–µ–æ–ª–æ–∫–∞—Ü–∏—è
async def location_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if context.user_data.get("step") != "NOTIFY_WAIT_GEO":
        return
    # —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞–∫ —Ä–∞–Ω—å—à–µ‚Ä¶

# –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º —Ö–µ–Ω–¥–ª–µ—Ä—ã
application.add_handler(CommandHandler("start", start_line))
application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))
application.add_handler(MessageHandler(filters.LOCATION, location_handler))

# –ó–∞–ø—É—Å–∫ webhook
if __name__ == "__main__":
    threading.Thread(target=lambda: requests.get(f"{SELF_URL}/webhook"), daemon=True).start()
    application.run_webhook(
        listen="0.0.0.0",
        port=PORT,
        url_path="webhook",
        webhook_url=f"{SELF_URL}/webhook"
    )
