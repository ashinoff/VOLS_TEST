# main.py

import os
import threading
import re
import requests
import pandas as pd
from io import StringIO
from flask import Flask
from telegram import Update, ReplyKeyboardMarkup, KeyboardButton
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
)

from config import (
    TOKEN, SELF_URL, PORT,
    BRANCH_URLS, VISIBILITY_GROUPS,
    NOTIFY_SHEET_URL
)
from zones import normalize_sheet_url, load_zones

app = Flask(__name__)
application = ApplicationBuilder().token(TOKEN).build()

# ‚Äî –æ–±—â–∏–µ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã ‚Äî
kb_back = ReplyKeyboardMarkup([["üîô –ù–∞–∑–∞–¥"]], resize_keyboard=True)

def build_initial_kb(vis_flag: str) -> ReplyKeyboardMarkup:
    # –æ–±–Ω–æ–≤–ª—ë–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è: RU ‚Üí UG, —è–≤–Ω–∞—è –≤–µ—Ç–∫–∞ –¥–ª—è RK
    if vis_flag == "All":
        nets = ["–†–æ—Å—Å–µ—Ç–∏ –Æ–ì", "–†–æ—Å—Å–µ—Ç–∏ –ö—É–±–∞–Ω—å"]
    elif vis_flag == "UG":       # –≤–º–µ—Å—Ç–æ RU
        nets = ["–†–æ—Å—Å–µ—Ç–∏ –Æ–ì"]
    elif vis_flag == "RK":
        nets = ["–†–æ—Å—Å–µ—Ç–∏ –ö—É–±–∞–Ω—å"]
    else:
        nets = []
    buttons = [[n] for n in nets] + [["–¢–µ–ª–µ—Ñ–æ–Ω—ã –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤"], ["–°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –æ—Ç—á—ë—Ç"]]
    return ReplyKeyboardMarkup(buttons, resize_keyboard=True)

def build_branch_kb(uid: int, selected_net: str, branch_map: dict) -> ReplyKeyboardMarkup:
    user_branch = branch_map[uid]
    if user_branch != "All":
        branches = [user_branch]
    else:
        branches = VISIBILITY_GROUPS[selected_net]
    btns = [[b] for b in branches] + [["üîô –ù–∞–∑–∞–¥"]]
    return ReplyKeyboardMarkup(btns, resize_keyboard=True)

kb_actions = ReplyKeyboardMarkup(
    [["üîç –ü–æ–∏—Å–∫ –ø–æ –¢–ü"], ["üîî –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ"], ["üîô –ù–∞–∑–∞–¥"]],
    resize_keyboard=True
)
kb_request_location = ReplyKeyboardMarkup(
    [[KeyboardButton("üìç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é", request_location=True)], ["üîô –ù–∞–∑–∞–¥"]],
    resize_keyboard=True
)

# ‚Äî /start ‚Äî
async def start_line(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    vis_map, branch_map, res_map, names, resp_map = load_zones()
    if uid not in branch_map:
        await update.message.reply_text("üö´ –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞.", reply_markup=kb_back)
        return

    context.user_data.clear()
    context.user_data.update({
        "step":       "INIT",
        "vis_flag":   vis_map[uid],      # All/UG/RK
        "branch_user":branch_map[uid],
        "res_user":   res_map[uid],      # –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –†–≠–° –∏–ª–∏ All
        "name":       names[uid],
        "resp_map":   resp_map
    })

    kb = build_initial_kb(vis_map[uid])
    await update.message.reply_text(f"–ü—Ä–∏–≤–µ—Ç, {names[uid]}! –í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:", reply_markup=kb)

# ‚Äî –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π ‚Äî
async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text.strip()
    uid  = update.effective_user.id
    vis_map, branch_map, res_map, names, resp_map = load_zones()
    if uid not in branch_map:
        return await update.message.reply_text("üö´ –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞.", reply_markup=kb_back)

    step        = context.user_data.get("step", "INIT")
    vis_flag    = context.user_data["vis_flag"]
    branch_user = context.user_data["branch_user"]
    res_user    = context.user_data["res_user"]
    user_name   = context.user_data["name"]

    # ‚Äî –ù–∞–∑–∞–¥ ‚Äî
    if text == "üîô –ù–∞–∑–∞–¥":
        if step in (
            "AWAIT_TP_INPUT","DISAMBIGUOUS",
            "NOTIFY_AWAIT_TP","NOTIFY_DISAMBIGUOUS","NOTIFY_AWAIT_VL","NOTIFY_WAIT_GEO"
        ):
            context.user_data["step"] = "BRANCH_SELECTED"
            return await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=kb_actions)
        if step == "NETWORK_SELECTED":
            context.user_data["step"] = "INIT"
            return await update.message.reply_text(
                "–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:", reply_markup=build_initial_kb(vis_flag)
            )
        context.user_data["step"] = "INIT"
        return await update.message.reply_text(
            "–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:", reply_markup=build_initial_kb(vis_flag)
        )

    # ‚Äî INIT: –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é ‚Äî
    if step == "INIT":
        if text == "–¢–µ–ª–µ—Ñ–æ–Ω—ã –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤":
            context.user_data["step"] = "VIEW_PHONES"
            return await update.message.reply_text("üìû –¢–µ–ª–µ—Ñ–æ–Ω—ã –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤:\n‚Ä¶", reply_markup=kb_back)
        if text == "–°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –æ—Ç—á—ë—Ç":
            context.user_data["step"] = "VIEW_REPORT"
            return await update.message.reply_text("üìù –û—Ç—á—ë—Ç —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω.", reply_markup=kb_back)

        # –æ–±–Ω–æ–≤–ª—ë–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ allowed_nets
        if vis_flag == "All":
            allowed_nets = ["–†–æ—Å—Å–µ—Ç–∏ –Æ–ì", "–†–æ—Å—Å–µ—Ç–∏ –ö—É–±–∞–Ω—å"]
        elif vis_flag == "UG":
            allowed_nets = ["–†–æ—Å—Å–µ—Ç–∏ –Æ–ì"]
        elif vis_flag == "RK":
            allowed_nets = ["–†–æ—Å—Å–µ—Ç–∏ –ö—É–±–∞–Ω—å"]
        else:
            allowed_nets = []

        if text in allowed_nets:
            context.user_data["step"]        = "NETWORK_SELECTED"
            context.user_data["selected_net"] = text
            kb = build_branch_kb(uid, text, branch_map)
            return await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∏–ª–∏–∞–ª:", reply_markup=kb)

        return await update.message.reply_text(
            f"{user_name}, –º–æ–∂–µ—Ç–µ –ø—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ: {', '.join(allowed_nets)} üòï",
            reply_markup=build_initial_kb(vis_flag)
        )

    # ‚Äî NETWORK_SELECTED: –≤—ã–±–æ—Ä —Ñ–∏–ª–∏–∞–ª–∞ ‚Äî
    if step == "NETWORK_SELECTED":
        selected_net = context.user_data["selected_net"]
        if branch_user != "All":
            allowed_branches = [branch_user]
        else:
            allowed_branches = VISIBILITY_GROUPS[selected_net]

        if text in allowed_branches:
            context.user_data["step"] = "BRANCH_SELECTED"
            context.user_data["current_branch"] = text
            return await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=kb_actions)

        return await update.message.reply_text(
            f"{user_name}, –º–æ–∂–µ—Ç–µ –ø—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ —Ñ–∏–ª–∏–∞–ª(—ã): {', '.join(allowed_branches)} üòï",
            reply_markup=build_branch_kb(uid, selected_net, branch_map)
        )

    # ‚Äî BRANCH_SELECTED –∏ –¥–∞–ª–µ–µ –æ—Å—Ç–∞–≤–ª—è–µ–º –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π ‚Äî
    # ‚Ä¶ –≤–∞—à –∫–æ–¥ AWAIT_TP_INPUT, DISAMBIGUOUS, NOTIFY_‚Ä¶ –∏ location_handler ‚Ä¶

# ‚Äî –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º —Ö–µ–Ω–¥–ª–µ—Ä—ã ‚Äî
application.add_handler(CommandHandler("start", start_line))
application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))
application.add_handler(MessageHandler(filters.LOCATION, location_handler))

if __name__ == "__main__":
    threading.Thread(target=lambda: requests.get(f"{SELF_URL}/webhook"), daemon=True).start()
    application.run_webhook(
        listen="0.0.0.0", port=PORT,
        url_path="webhook", webhook_url=f"{SELF_URL}/webhook"
    )
