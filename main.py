import os
import threading
import re
import requests
import pandas as pd
from io import StringIO
from flask import Flask
from telegram import Update, ReplyKeyboardMarkup, KeyboardButton
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
)

from config import TOKEN, SELF_URL, PORT, BRANCH_URLS, NOTIFY_SHEET_URL
from zones import normalize_sheet_url, load_zones

# ‚Äî Flask & PTB setup ‚Äî
app = Flask(__name__)
application = ApplicationBuilder().token(TOKEN).build()

# ‚Äî –û–±—â–∏–µ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã ‚Äî
kb_back = ReplyKeyboardMarkup([["üîô –ù–∞–∑–∞–¥"]], resize_keyboard=True)

kb_actions = ReplyKeyboardMarkup(
    [["üîç –ü–æ–∏—Å–∫ –ø–æ –¢–ü"], ["üîî –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ"], ["üîô –ù–∞–∑–∞–¥"]],
    resize_keyboard=True
)
kb_request_location = ReplyKeyboardMarkup(
    [[KeyboardButton("üìç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é", request_location=True)], ["üîô –ù–∞–∑–∞–¥"]],
    resize_keyboard=True
)

def build_initial_kb(vis_flag: str) -> ReplyKeyboardMarkup:
    """
    –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é: ‚ö° –†–æ—Å—Å–µ—Ç–∏ –Æ–ì / ‚ö° –†–æ—Å—Å–µ—Ç–∏ –ö—É–±–∞–Ω—å –ø–æ vis_flag,
    –ø–ª—é—Å —Ç–µ–ª–µ—Ñ–æ–Ω—ã –∏ –æ—Ç—á—ë—Ç.
    """
    flag = vis_flag.strip().upper()
    if flag == "ALL":
        nets = ["‚ö° –†–æ—Å—Å–µ—Ç–∏ –Æ–ì", "‚ö° –†–æ—Å—Å–µ—Ç–∏ –ö—É–±–∞–Ω—å"]
    elif flag == "UG":
        nets = ["‚ö° –†–æ—Å—Å–µ—Ç–∏ –Æ–ì"]
    elif flag == "RK":
        nets = ["‚ö° –†–æ—Å—Å–µ—Ç–∏ –ö—É–±–∞–Ω—å"]
    else:
        nets = []

    buttons = [[n] for n in nets] + [
        ["üìû –¢–µ–ª–µ—Ñ–æ–Ω—ã –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤"],
        ["üìù –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –æ—Ç—á—ë—Ç"]
    ]
    return ReplyKeyboardMarkup(buttons, resize_keyboard=True)

def build_branch_kb(uid: int, selected_net: str, branch_map: dict) -> ReplyKeyboardMarkup:
    """
    –ú–µ–Ω—é —Ñ–∏–ª–∏–∞–ª–æ–≤: –µ—Å–ª–∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ–¥–∏–Ω —Ñ–∏–ª–∏–∞–ª ‚Äî —Ç–æ–ª—å–∫–æ –æ–Ω,
    –∏–Ω–∞—á–µ ‚Äî –≤—Å–µ –∫–ª—é—á–∏ BRANCH_URLS[selected_net].
    """
    user_branch = branch_map.get(uid, "All")
    if user_branch != "All":
        branches = [user_branch]
    else:
        branches = list(BRANCH_URLS[selected_net].keys())

    btns = [[b] for b in branches] + [["üîô –ù–∞–∑–∞–¥"]]
    return ReplyKeyboardMarkup(btns, resize_keyboard=True)

# ‚Äî /start ‚Äî
async def start_line(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    vis_map, raw_branch_map, res_map, names, resp_map = load_zones()

    # –§–∏–ª—å—Ç—Ä—É–µ–º raw_branch_map —Ç–æ–ª—å–∫–æ –ø–æ —Ç–µ–º, —á—Ç–æ –µ—Å—Ç—å –≤ BRANCH_URLS
    all_branches = sum((list(v.keys()) for v in BRANCH_URLS.values()), [])
    branch_map = {u: b for u, b in raw_branch_map.items() if b in all_branches}

    if uid not in branch_map:
        await update.message.reply_text("üö´ –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞.", reply_markup=kb_back)
        return

    context.user_data.clear()
    context.user_data.update({
        "step":        "INIT",
        "vis_flag":    vis_map[uid],
        "branch_user": branch_map[uid],
        "res_user":    res_map[uid],
        "resp_map":    resp_map,
        "name":        names[uid],
    })

    kb = build_initial_kb(vis_map[uid])
    await update.message.reply_text(
        f"üëã –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤—É—é –í–∞—Å, {names[uid]}! –í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:",
        reply_markup=kb
    )

# ‚Äî –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π ‚Äî
async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text.strip()
    uid  = update.effective_user.id

    # –ü–æ–¥–≥—Ä—É–∂–∞–µ–º —Å–≤–µ–∂–∏–µ –∑–æ–Ω—ã
    vis_map, raw_branch_map, res_map, names, _ = load_zones()
    all_branches = sum((list(v.keys()) for v in BRANCH_URLS.values()), [])
    branch_map = {u: b for u, b in raw_branch_map.items() if b in all_branches}

    if uid not in branch_map:
        await update.message.reply_text("üö´ –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞.", reply_markup=kb_back)
        return

    step        = context.user_data.get("step", "INIT")
    vis_flag    = context.user_data["vis_flag"]
    branch_user = context.user_data["branch_user"]
    res_user    = context.user_data["res_user"]
    resp_flag   = context.user_data["resp_map"].get(uid, "").strip()
    user_name   = context.user_data["name"]

    # ‚Äî –ù–∞–∑–∞–¥ ‚Äî
    if text == "üîô –ù–∞–∑–∞–¥":
        if step in (
            "AWAIT_TP_INPUT", "DISAMBIGUOUS",
            "NOTIFY_AWAIT_TP", "NOTIFY_DISAMBIGUOUS",
            "NOTIFY_AWAIT_VL", "NOTIFY_WAIT_GEO"
        ):
            context.user_data["step"] = "BRANCH_SELECTED"
            await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=kb_actions)
            return

        if step == "NETWORK_SELECTED":
            context.user_data["step"] = "INIT"
            kb = build_initial_kb(vis_flag)
            await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:", reply_markup=kb)
            return

        context.user_data["step"] = "INIT"
        kb = build_initial_kb(vis_flag)
        await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:", reply_markup=kb)
        return

    # ‚Äî INIT: –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é ‚Äî
    if step == "INIT":
        if text == "üìû –¢–µ–ª–µ—Ñ–æ–Ω—ã –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤":
            context.user_data["step"] = "VIEW_PHONES"
            await update.message.reply_text("üìû –¢–µ–ª–µ—Ñ–æ–Ω—ã –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤:\n‚Ä¶", reply_markup=kb_back)
            return

        if text == "üìù –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –æ—Ç—á—ë—Ç":
            context.user_data["step"] = "VIEW_REPORT"
            await update.message.reply_text("üìù –û—Ç—á—ë—Ç —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω.", reply_markup=kb_back)
            return

        flag = vis_flag.strip().upper()
        if flag == "ALL":
            allowed = ["‚ö° –†–æ—Å—Å–µ—Ç–∏ –Æ–ì", "‚ö° –†–æ—Å—Å–µ—Ç–∏ –ö—É–±–∞–Ω—å"]
        elif flag == "UG":
            allowed = ["‚ö° –†–æ—Å—Å–µ—Ç–∏ –Æ–ì"]
        else:
            allowed = ["‚ö° –†–æ—Å—Å–µ—Ç–∏ –ö—É–±–∞–Ω—å"]

        if text in allowed:
            selected_net = text.replace("‚ö° ", "")
            context.user_data["step"]         = "NETWORK_SELECTED"
            context.user_data["selected_net"] = selected_net
            kb = build_branch_kb(uid, selected_net, branch_map)
            await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∏–ª–∏–∞–ª:", reply_markup=kb)
        else:
            await update.message.reply_text(
                f"{user_name}, –º–æ–∂–µ—Ç–µ –ø—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ: {', '.join(allowed)} üòï",
                reply_markup=build_initial_kb(vis_flag)
            )
        return

    # ‚Äî NETWORK_SELECTED: –≤—ã–±–æ—Ä —Ñ–∏–ª–∏–∞–ª–∞ ‚Äî
    if step == "NETWORK_SELECTED":
        selected_net = context.user_data["selected_net"]
        allowed = [branch_user] if branch_user != "All" else list(BRANCH_URLS[selected_net].keys())

        if text in allowed:
            context.user_data["step"]           = "BRANCH_SELECTED"
            context.user_data["current_branch"] = text
            await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=kb_actions)
        else:
            await update.message.reply_text(
                f"{user_name}, –º–æ–∂–µ—Ç–µ –ø—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ: {', '.join(allowed)} üòï",
                reply_markup=build_branch_kb(uid, selected_net, branch_map)
            )
        return

    # ‚Äî BRANCH_SELECTED: –¥–µ–π—Å—Ç–≤–∏—è –≤ —Ñ–∏–ª–∏–∞–ª–µ ‚Äî
    if step == "BRANCH_SELECTED":
        if text == "üîç –ü–æ–∏—Å–∫ –ø–æ –¢–ü":
            context.user_data["step"] = "AWAIT_TP_INPUT"
            await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –¢–ü:", reply_markup=kb_back)
            return

        if text == "üîî –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ":
            if resp_flag:
                await update.message.reply_text(
                    f"{user_name}, –≤—ã –Ω–µ –º–æ–∂–µ—Ç–µ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è üòï",
                    reply_markup=kb_actions
                )
                return
            context.user_data["step"] = "NOTIFY_AWAIT_TP"
            await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –¢–ü –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:", reply_markup=kb_back)
            return

        return

    # ‚Äî AWAIT_TP_INPUT: –ø—Ä–æ—Å—Ç–æ–π –ø–æ–∏—Å–∫ –ø–æ –¢–ü ‚Äî
    if step == "AWAIT_TP_INPUT":
        selected_net    = context.user_data["selected_net"]
        current_branch  = context.user_data["current_branch"]
        # –ø–æ–¥–±–∏—Ä–∞–µ–º URL –ø–æ —Å–µ—Ç–∏ –∏ —Ñ–∏–ª–∏–∞–ª—É
        url = BRANCH_URLS[selected_net][current_branch]
        df  = pd.read_csv(normalize_sheet_url(url))

        if res_user != "All":
            norm = lambda s: re.sub(r'\W','', str(s).upper())
            df = df[df["–†–≠–°"].apply(norm) == norm(res_user)]

        df.columns = df.columns.str.strip()
        df["D_UP"] = df["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"].str.upper().str.replace(r'\W','', regex=True)

        q     = re.sub(r'\W','', text.upper())
        found = df[df["D_UP"].str.contains(q, na=False)]
        if found.empty:
            await update.message.reply_text(
                "üîç –ù–µ—Ç –¥–æ–≥–æ–≤–æ—Ä–æ–≤ –∏–ª–∏ –Ω–µ–≤–µ—Ä–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ. –í–≤–µ–¥–∏—Ç–µ —Å–Ω–æ–≤–∞:",
                reply_markup=kb_back
            )
            return

        unique_tp = found["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"].unique().tolist()
        if len(unique_tp) > 1:
            context.user_data["step"] = "DISAMBIGUOUS"
            context.user_data["ambiguous_df"] = found
            kb = ReplyKeyboardMarkup([[tp] for tp in unique_tp] + [["üîô –ù–∞–∑–∞–¥"]],
                                     resize_keyboard=True)
            await update.message.reply_text("–ù–∞–π–¥–µ–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ –¢–ü ‚Äì –≤—ã–±–µ—Ä–∏—Ç–µ:", reply_markup=kb)
            return

        tp_sel  = unique_tp[0]
        details = found[found["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"] == tp_sel]
        cnt     = len(details)
        res_name= details.iloc[0]["–†–≠–°"]

        await update.message.reply_text(
            f"{res_name}, {tp_sel} ({cnt}) –í–û–õ–° —Å –¥–æ–≥–æ–≤–æ—Ä–æ–º –∞—Ä–µ–Ω–¥—ã.\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
            reply_markup=kb_actions
        )
        for _, r in details.iterrows():
            await update.message.reply_text(
                f"üìç –í–õ {r['–£—Ä–æ–≤–µ–Ω—å –Ω–∞–ø—Ä—è–∂–µ–Ω–∏—è']} {r['–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –í–õ']}\n"
                f"–û–ø–æ—Ä—ã: {r['–û–ø–æ—Ä—ã']}\n–ü—Ä–æ–≤–∞–π–¥–µ—Ä: {r.get('–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –ü—Ä–æ–≤–∞–π–¥–µ—Ä–∞','')}",
                reply_markup=kb_actions
            )

        context.user_data["step"] = "BRANCH_SELECTED"
        return

    # ‚Äî DISAMBIGUOUS: —É—Ç–æ—á–Ω–µ–Ω–∏–µ –¢–ü ‚Äî
    if step == "DISAMBIGUOUS":
        if text == "üîô –ù–∞–∑–∞–¥":
            context.user_data["step"] = "AWAIT_TP_INPUT"
            await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –¢–ü:", reply_markup=kb_back)
            return

        df_amb = context.user_data["ambiguous_df"]
        if text in df_amb["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"].unique():
            details = df_amb[df_amb["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"] == text]
            cnt     = len(details)
            res_name= details.iloc[0]["–†–≠–°"]

            await update.message.reply_text(
                f"{res_name}, {text} ({cnt}) –í–û–õ–° —Å –¥–æ–≥–æ–≤–æ—Ä–æ–º –∞—Ä–µ–Ω–¥—ã.\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
                reply_markup=kb_actions
            )
            for _, r in details.iterrows():
                await update.message.reply_text(
                    f"üìç –í–õ {r['–£—Ä–æ–≤–µ–Ω—å –Ω–∞–ø—Ä—è–∂–µ–Ω–∏—è']} {r['–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –í–õ']}\n"
                    f"–û–ø–æ—Ä—ã: {r['–û–ø–æ—Ä—ã']}\n–ü—Ä–æ–≤–∞–π–¥–µ—Ä: {r.get('–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –ü—Ä–æ–≤–∞–π–¥–µ—Ä–∞','')}",
                    reply_markup=kb_actions
                )
            context.user_data["step"] = "BRANCH_SELECTED"
        return

    # ‚Äî NOTIFY_AWAIT_TP / NOTIFY_DISAMBIGUOUS / NOTIFY_AWAIT_VL ‚Äî  
    # (–æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –±—ã–ª–æ)

# ‚Äî –ì–µ–æ–ª–æ–∫–∞—Ü–∏—è –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π ‚Äî
async def location_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if context.user_data.get("step") != "NOTIFY_WAIT_GEO":
        return

    loc = update.message.location
    sender_name = context.user_data["name"]
    tp          = context.user_data["notify_tp"]
    vl          = context.user_data["notify_vl"]
    notify_res  = context.user_data["notify_res"]

    _, _, _, _, resp_map2 = load_zones()
    recipients = [u for u, r in resp_map2.items() if r == notify_res]

    notif_text = (
        f"üîî –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç {sender_name}, {notify_res} –†–≠–°, {tp}, {vl} ‚Äì "
        "–ù–∞–π–¥–µ–Ω –±–µ–∑–¥–æ–≥–æ–≤–æ—Ä–Ω–æ–π –í–û–õ–°"
    )
    for cid in recipients:
        await context.bot.send_message(chat_id=cid, text=notif_text)
        await context.bot.send_location(chat_id=cid,
                                        latitude=loc.latitude,
                                        longitude=loc.longitude)
        await context.bot.send_message(
            chat_id=cid,
            text=f"üìç –®–∏—Ä–æ—Ç–∞: {loc.latitude:.6f}, –î–æ–ª–≥–æ—Ç–∞: {loc.longitude:.6f}"
        )

    await update.message.reply_text(
        f"‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {', '.join(map(str, recipients))}",
        reply_markup=kb_actions
    )
    context.user_data["step"] = "BRANCH_SELECTED"

# ‚Äî –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º —Ö–µ–Ω–¥–ª–µ—Ä—ã ‚Äî
application.add_handler(CommandHandler("start", start_line))
application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))
application.add_handler(MessageHandler(filters.LOCATION, location_handler))

# ‚Äî –ó–∞–ø—É—Å–∫ –≤–µ–±—Ö—É–∫–∞ ‚Äî
if __name__ == "__main__":
    threading.Thread(target=lambda: requests.get(f"{SELF_URL}/webhook"), daemon=True).start()
    application.run_webhook(
        listen="0.0.0.0",
        port=PORT,
        url_path="webhook",
        webhook_url=f"{SELF_URL}/webhook"
    )
