# main.py

import os
import threading
import re
import requests
import pandas as pd
import csv
from datetime import datetime, timezone
from io import BytesIO

from flask import Flask
from telegram import Update, ReplyKeyboardMarkup, KeyboardButton
from telegram.ext import (
    ApplicationBuilder, CommandHandler,
    MessageHandler, filters, ContextTypes,
)

from config import (
    TOKEN, SELF_URL, PORT,
    BRANCH_URLS, NOTIFY_URLS,
    NOTIFY_LOG_FILE_UG, NOTIFY_LOG_FILE_RK,
    HELP_FOLDER
)
from zones import normalize_sheet_url, load_zones

# –°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ ¬´—Å—ã—Ä–æ–≥–æ¬ª –Ω–∞–∑–≤–∞–Ω–∏—è —Ñ–∏–ª–∏–∞–ª–∞ (–∏–∑ CSV) –≤ –∫–ª—é—á BRANCH_URLS
BRANCH_KEY_MAP = {
    "–¢–∏–º–∞—à–µ–≤—Å–∫–∏–π":      "–¢–∏–º–∞—à–µ–≤—Å–∫–∏–µ –≠–°",
    "–£—Å—Ç—å-–õ–∞–±–∏–Ω—Å–∫–∏–π":   "–£—Å—Ç—å-–õ–∞–±–∏–Ω—Å–∫–∏–µ –≠–°",
    "–¢–∏—Ö–æ—Ä–µ—Ü–∫–∏–π":       "–¢–∏—Ö–æ—Ä–µ—Ü–∫–∏–µ –≠–°",
    "–°–æ—á–∏–Ω—Å–∫–∏–π":        "–°–æ—á–∏–Ω—Å–∫–∏–µ –≠–°",
    "–°–ª–∞–≤—è–Ω—Å–∫–∏–π":       "–°–ª–∞–≤—è–Ω—Å–∫–∏–µ –≠–°",
    "–õ–µ–Ω–∏–Ω–≥—Ä–∞–¥—Å–∫–∏–π":    "–õ–µ–Ω–∏–Ω–≥—Ä–∞–¥—Å–∫–∏–µ –≠–°",
    "–õ–∞–±–∏–Ω—Å–∫–∏–π":        "–õ–∞–±–∏–Ω—Å–∫–∏–µ –≠–°",
    "–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π":    "–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–µ –≠–°",
    "–ê—Ä–º–∞–≤–∏—Ä—Å–∫–∏–π":      "–ê—Ä–º–∞–≤–∏—Ä—Å–∫–∏–µ –≠–°",
    "–ê–¥—ã–≥–µ–π—Å–∫–∏–π":       "–ê–¥—ã–≥–µ–π—Å–∫–∏–µ –≠–°",
    "–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π":      "–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–µ –≠–°",
    "–ó–∞–ø–∞–¥–Ω—ã–π":         "–ó–∞–ø–∞–¥–Ω—ã–µ –≠–°",
    "–í–æ—Å—Ç–æ—á–Ω—ã–π":        "–í–æ—Å—Ç–æ—á–Ω—ã–µ –≠–°",
    "–Æ–∂–Ω—ã–π":            "–Æ–∂–Ω—ã–µ –≠–°",
    "–°–µ–≤–µ—Ä–æ-–í–æ—Å—Ç–æ—á–Ω—ã–π": "–°–µ–≤–µ—Ä–æ-–í–æ—Å—Ç–æ—á–Ω—ã–µ –≠–°",
    "–Æ–≥–æ-–í–æ—Å—Ç–æ—á–Ω—ã–π":    "–Æ–≥–æ-–í–æ—Å—Ç–æ—á–Ω—ã–µ –≠–°",
    "–°–µ–≤–µ—Ä–Ω—ã–π":         "–°–µ–≤–µ—Ä–Ω—ã–µ –≠–°",
}

app = Flask(__name__)
application = ApplicationBuilder().token(TOKEN).build()

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–∞–ø–∫–∏ —Å–ø—Ä–∞–≤–∫–∏
if HELP_FOLDER:
    os.makedirs(HELP_FOLDER, exist_ok=True)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è CSV-—Ñ–∞–π–ª–æ–≤ –ª–æ–≥–æ–≤ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
for lf in (NOTIFY_LOG_FILE_UG, NOTIFY_LOG_FILE_RK):
    if not os.path.exists(lf):
        with open(lf, "w", newline="", encoding="utf-8") as f:
            csv.writer(f).writerow([
                "Filial","–†–≠–°",
                "SenderID","SenderName",
                "RecipientID","RecipientName",
                "Timestamp","Coordinates"
            ])

# --- –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã ---
kb_back = ReplyKeyboardMarkup([["üîô –ù–∞–∑–∞–¥"]], resize_keyboard=True)
kb_actions = ReplyKeyboardMarkup(
    [["üîç –ü–æ–∏—Å–∫ –ø–æ –¢–ü"], ["üîî –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ"], ["‚ÑπÔ∏è –°–ø—Ä–∞–≤–∫–∞"], ["üîô –ù–∞–∑–∞–¥"]],
    resize_keyboard=True
)
kb_request_location = ReplyKeyboardMarkup(
    [[KeyboardButton("üìç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é", request_location=True)],
     ["‚ÑπÔ∏è –°–ø—Ä–∞–≤–∫–∞"], ["üîô –ù–∞–∑–∞–¥"]],
    resize_keyboard=True
)

def build_initial_kb(vis_flag: str, res_flag: str) -> ReplyKeyboardMarkup:
    f = vis_flag.strip().upper()
    if f == "ALL":
        nets = ["‚ö° –†–æ—Å—Å–µ—Ç–∏ –Æ–ì", "‚ö° –†–æ—Å—Å–µ—Ç–∏ –ö—É–±–∞–Ω—å"]
    elif f == "UG":
        nets = ["‚ö° –†–æ—Å—Å–µ—Ç–∏ –Æ–ì"]
    else:
        nets = ["‚ö° –†–æ—Å—Å–µ—Ç–∏ –ö—É–±–∞–Ω—å"]
    buttons = [[n] for n in nets] + [["üìû –¢–µ–ª–µ—Ñ–æ–Ω—ã –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤"]]
    if res_flag.strip().upper() == "ALL":
        buttons += [["üìù –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –æ—Ç—á—ë—Ç"]]
    buttons += [["‚ÑπÔ∏è –°–ø—Ä–∞–≤–∫–∞"]]
    return ReplyKeyboardMarkup(buttons, resize_keyboard=True)

def build_report_kb(vis_flag: str) -> ReplyKeyboardMarkup:
    f = vis_flag.strip().upper()
    rows = []
    if f in ("ALL", "UG"):
        rows.append(["üìä –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –±–µ–∑–¥–æ–≥–æ–≤–æ—Ä–Ω—ã—Ö –í–û–õ–° –Æ–ì"])
    if f in ("ALL", "RK"):
        rows.append(["üìä –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –±–µ–∑–¥–æ–≥–æ–≤–æ—Ä–Ω—ã—Ö –í–û–õ–° –ö—É–±–∞–Ω—å"])
    rows += [["üìã –í—ã–≥—Ä—É–∑–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –ø–æ –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç–∞–º"], ["‚ÑπÔ∏è –°–ø—Ä–∞–≤–∫–∞"], ["üîô –ù–∞–∑–∞–¥"]]
    return ReplyKeyboardMarkup(rows, resize_keyboard=True)

# --- /start ---
async def start_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    vis_map, branch_map, res_map, names, resp_map = load_zones()
    if uid not in branch_map:
        return await update.message.reply_text("üö´ –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞.", reply_markup=kb_back)

    raw_branch = branch_map[uid]
    branch_key = "All" if raw_branch == "All" else BRANCH_KEY_MAP.get(raw_branch, raw_branch)

    context.user_data.clear()
    context.user_data.update({
        "step":        "INIT",
        "vis_flag":    vis_map[uid],
        "res_user":    res_map[uid],
        "branch_user": branch_key,
        "name":        names[uid],
        "resp_map":    resp_map
    })

    await update.message.reply_text(
        f"üëã –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤—É—é –í–∞—Å, {names[uid]}! –í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:",
        reply_markup=build_initial_kb(vis_map[uid], res_map[uid])
    )

# --- TEXT handler ---
async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text.strip()
    data = context.user_data

    # 1) –°–ø—Ä–∞–≤–∫–∞: —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤
    if text == "‚ÑπÔ∏è –°–ø—Ä–∞–≤–∫–∞" and data.get("step") != "HELP_LIST":
        data["prev_step"] = data.get("step", "INIT")
        try:
            files = sorted(os.listdir(HELP_FOLDER))
        except:
            return await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ —Å–ø—Ä–∞–≤–∫–µ.", reply_markup=kb_back)
        data["help_files"] = files
        data["step"] = "HELP_LIST"
        kb = ReplyKeyboardMarkup([[f] for f in files] + [["üîô –ù–∞–∑–∞–¥"]], resize_keyboard=True)
        return await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª —Å–ø—Ä–∞–≤–∫–∏:", reply_markup=kb)

    # 2) –ú–µ–Ω—é —Å–ø—Ä–∞–≤–∫–∏: –≤—ã–¥–∞–µ–º —Ñ–∞–π–ª
    if data.get("step") == "HELP_LIST":
        if text == "üîô –ù–∞–∑–∞–¥":
            data["step"] = data.get("prev_step", "INIT")
            return await restore_menu(update, context)
        if text in data.get("help_files", []):
            path = os.path.join(HELP_FOLDER, text)
            if text.lower().endswith((".jpg", ".jpeg", ".png", ".gif")):
                await update.message.reply_photo(open(path, "rb"))
            else:
                await update.message.reply_document(open(path, "rb"))
            data["step"] = data.get("prev_step", "INIT")
            return await restore_menu(update, context)

    # –î–∞–ª–µ–µ ‚Äî –≤–µ—Å—å –≤–∞—à –ø—Ä–µ–∂–Ω–∏–π –∫–æ–¥, —Å —Ç–æ—á–Ω—ã–º–∏ —à–∞–≥–∞–º–∏ INIT, REPORT_MENU, NET, BRANCH, AWAIT_TP_INPUT, DISAMB, NOTIFY_‚Ä¶
    # –Ø –ø—Ä–∏–≤–æ–∂—É –µ–≥–æ –∑–¥–µ—Å—å —Ü–µ–ª–∏–∫–æ–º:

    vis_map, branch_map, res_map, names, resp_map = load_zones()
    step        = data.get("step", "INIT")
    vis_flag    = data["vis_flag"]
    res_user    = data["res_user"]
    branch_user = data["branch_user"]
    name        = data["name"]

    # ¬´–ù–∞–∑–∞–¥¬ª –≤–æ –≤—Å–µ—Ö —Ä–µ–∂–∏–º–∞—Ö
    if text == "üîô –ù–∞–∑–∞–¥":
        if step in ("AWAIT_TP_INPUT","DISAMB","NOTIFY_AWAIT_TP","NOTIFY_DISAMB","NOTIFY_VL"):
            data["step"] = "BRANCH"
            return await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=kb_actions)
        if step == "REPORT_MENU":
            data["step"] = "INIT"
            return await update.message.reply_text(
                f"üëã –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤—É—é –í–∞—Å, {name}! –í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:",
                reply_markup=build_initial_kb(vis_flag, res_user)
            )
        data["step"] = "INIT"
        return await update.message.reply_text(
            "–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:", reply_markup=build_initial_kb(vis_flag, res_user)
        )

    # INIT
    if step == "INIT":
        if text == "üìû –¢–µ–ª–µ—Ñ–æ–Ω—ã –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤":
            data["step"] = "VIEW_PHONES"
            return await update.message.reply_text("üìû –¢–µ–ª–µ—Ñ–æ–Ω—ã –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤:\n‚Ä¶", reply_markup=kb_back)
        if text == "üìù –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –æ—Ç—á—ë—Ç":
            data["step"] = "REPORT_MENU"
            return await update.message.reply_text("üìù –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –æ—Ç—á—ë—Ç–∞:", reply_markup=build_report_kb(vis_flag))
        allowed = (["‚ö° –†–æ—Å—Å–µ—Ç–∏ –Æ–ì","‚ö° –†–æ—Å—Å–µ—Ç–∏ –ö—É–±–∞–Ω—å"] if vis_flag=="ALL"
                   else ["‚ö° –†–æ—Å—Å–µ—Ç–∏ –Æ–ì"] if vis_flag=="UG"
                   else ["‚ö° –†–æ—Å—Å–µ—Ç–∏ –ö—É–±–∞–Ω—å"])
        if text not in allowed:
            return await update.message.reply_text(
                f"{name}, –¥–æ—Å—Ç—É–ø–Ω—ã: {', '.join(allowed)}",
                reply_markup=build_initial_kb(vis_flag, res_user)
            )
        selected_net = text.replace("‚ö° ","")
        data.update({"step":"NET","net":selected_net})
        if branch_user != "All":
            branches = [branch_user]
        else:
            branches = list(BRANCH_URLS[selected_net].keys())
        kb = ReplyKeyboardMarkup([[b] for b in branches] + [["üîô –ù–∞–∑–∞–¥"]], resize_keyboard=True)
        return await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∏–ª–∏–∞–ª:", reply_markup=kb)

    # REPORT_MENU
    if step == "REPORT_MENU":
        if text == "üìä –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –±–µ–∑–¥–æ–≥–æ–≤–æ—Ä–Ω—ã—Ö –í–û–õ–° –Æ–ì":
            df = pd.read_csv(NOTIFY_LOG_FILE_UG)
            bio = BytesIO()
            with pd.ExcelWriter(bio, engine="openpyxl") as w:
                df.to_excel(w, index=False, sheet_name="UG")
            bio.seek(0)
            await update.message.reply_document(bio, filename="log_ug.xlsx")
        elif text == "üìä –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –±–µ–∑–¥–æ–≥–æ–≤–æ—Ä–Ω—ã—Ö –í–û–õ–° –ö—É–±–∞–Ω—å":
            df = pd.read_csv(NOTIFY_LOG_FILE_RK)
            bio = BytesIO()
            with pd.ExcelWriter(bio, engine="openpyxl") as w:
                df.to_excel(w, index=False, sheet_name="RK")
            bio.seek(0)
            await update.message.reply_document(bio, filename="log_rk.xlsx")
        elif text == "üìã –í—ã–≥—Ä—É–∑–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –ø–æ –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç–∞–º":
            return await update.message.reply_text(
                "üìã –°–ø—Ä–∞–≤–æ—á–Ω–∏–∫ –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç–æ–≤ ‚Äî —Å–∫–æ—Ä–æ –±—É–¥–µ—Ç!",
                reply_markup=build_report_kb(vis_flag)
            )
        return await update.message.reply_text("üìù –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –æ—Ç—á—ë—Ç–∞:", reply_markup=build_report_kb(vis_flag))

    # NET ‚Üí —Ñ–∏–ª–∏–∞–ª
    if step == "NET":
        selected_net = data["net"]
        if branch_user!="All" and text!=branch_user:
            return await update.message.reply_text(
                f"{name}, –¥–æ—Å—Ç—É–ø–µ–Ω —Ç–æ–ª—å–∫–æ —Ñ–∏–ª–∏–∞–ª ¬´{branch_user}¬ª.",
                reply_markup=kb_back
            )
        if text not in BRANCH_URLS[selected_net]:
            return await update.message.reply_text(
                f"‚ö† –§–∏–ª–∏–∞–ª ¬´{text}¬ª –Ω–µ –Ω–∞–π–¥–µ–Ω.",
                reply_markup=kb_back
            )
        data.update({"step":"BRANCH","branch":text})
        return await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=kb_actions)

    # BRANCH ‚Üí –¥–µ–π—Å—Ç–≤–∏–µ
    if step == "BRANCH":
        if text == "üîç –ü–æ–∏—Å–∫ –ø–æ –¢–ü":
            data["step"] = "AWAIT_TP_INPUT"
            return await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –¢–ü:", reply_markup=kb_back)
        if text == "üîî –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ":
            data["step"] = "NOTIFY_AWAIT_TP"
            return await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –¢–ü –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:", reply_markup=kb_back)

    # AWAIT_TP_INPUT
    if step == "AWAIT_TP_INPUT":
        net    = data["net"]
        branch = data["branch"]
        url    = BRANCH_URLS[net].get(branch,"").strip()
        if not url:
            data["step"] = "BRANCH"
            return await update.message.reply_text(f"‚ö†Ô∏è URL –¥–ª—è ¬´{branch}¬ª –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω.", reply_markup=kb_back)
        try:
            df = pd.read_csv(normalize_sheet_url(url))
        except Exception as e:
            data["step"] = "BRANCH"
            return await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: {e}", reply_markup=kb_back)

        if res_user!="ALL":
            df = df[df["–†–≠–°"].str.upper()==res_user.upper()]
        df["D_UP"] = df["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"].str.upper().str.replace(r"\W","",regex=True)
        q = re.sub(r"\W","", text.upper())
        found = df[df["D_UP"].str.contains(q, na=False)]
        if found.empty:
            data["step"] = "BRANCH"
            return await update.message.reply_text(
                f"‚ö† –í {res_user} –†–≠–° –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –¢–ü —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è—é—â–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–∏—Å–∫–∞.",
                reply_markup=kb_back
            )

        ulist = found["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"].unique().tolist()
        if len(ulist)>1:
            data.update({"step":"DISAMB","amb_df":found})
            kb = ReplyKeyboardMarkup([[tp] for tp in ulist] + [["üîô –ù–∞–∑–∞–¥"]], resize_keyboard=True)
            return await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –¢–ü:", reply_markup=kb)

        tp = ulist[0]
        det=found[found["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"]==tp]
        resname=det.iloc[0]["–†–≠–°"]
        await update.message.reply_text(f"{resname}, {tp} ({len(det)}) –í–û–õ–° —Å –¥–æ–≥–æ–≤–æ—Ä–æ–º –∞—Ä–µ–Ω–¥—ã:", reply_markup=kb_actions)
        for _,r in det.iterrows():
            await update.message.reply_text(
                f"üìç –í–õ {r['–£—Ä–æ–≤–µ–Ω—å –Ω–∞–ø—Ä—è–∂–µ–Ω–∏—è']} {r['–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –í–õ']}\n"
                f"–û–ø–æ—Ä—ã: {r['–û–ø–æ—Ä—ã']}\n"
                f"–ü—Ä–æ–≤–∞–π–¥–µ—Ä: {r.get('–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –ü—Ä–æ–≤–∞–π–¥–µ—Ä–∞','')}",
                reply_markup=kb_actions
            )
        data["step"]="BRANCH"
        return

    # DISAMB
    if step == "DISAMB":
        found = data["amb_df"]
        if text == "üîô –ù–∞–∑–∞–¥":
            data["step"]="AWAIT_TP_INPUT"
            return await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –¢–ü:", reply_markup=kb_back)
        if text in found["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"].unique():
            det=found[found["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"]==text]
            resname=det.iloc[0]["–†–≠–°"]
            await update.message.reply_text(f"{resname}, {text} ({len(det)}) –í–û–õ–° —Å –¥–æ–≥–æ–≤–æ—Ä–æ–º –∞—Ä–µ–Ω–¥—ã:", reply_markup=kb_actions)
            for _,r in det.iterrows():
                await update.message.reply_text(
                    f"üìç –í–õ {r['–£—Ä–æ–≤–µ–Ω—å –Ω–∞–ø—Ä—è–∂–µ–Ω–∏—è']} {r['–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –í–õ']}\n"
                    f"–û–ø–æ—Ä—ã: {r['–û–ø–æ—Ä—ã']}\n"
                    f"–ü—Ä–æ–≤–∞–π–¥–µ—Ä: {r.get('–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –ü—Ä–æ–≤–∞–π–¥–µ—Ä–∞','')}",
                    reply_markup=kb_actions
                )
            data["step"]="BRANCH"
            return

    # NOTIFY_AWAIT_TP
    if step == "NOTIFY_AWAIT_TP":
        net    = data["net"]
        branch = data["branch"]
        url    = NOTIFY_URLS[net].get(branch,"").strip()
        if not url:
            data["step"]="BRANCH"
            return await update.message.reply_text(f"‚ö†Ô∏è URL —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –¥–ª—è ¬´{branch}¬ª –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω.", reply_markup=kb_back)
        try:
            df = pd.read_csv(normalize_sheet_url(url))
        except Exception as e:
            data["step"]="BRANCH"
            return await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π: {e}", reply_markup=kb_back)
        df["D_UP"] = df["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"].str.upper().str.replace(r"\W","",regex=True)
        q = re.sub(r"\W","", text.upper())
        found = df[df["D_UP"].str.contains(q, na=False)]
        if found.empty:
            data["step"]="BRANCH"
            return await update.message.reply_text("üîî –¢–ü –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤ —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–µ.", reply_markup=kb_back)
        ulist = found["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"].unique().tolist()
        if len(ulist)>1:
            data.update({"step":"NOTIFY_DISAMB","amb_df_notify":found})
            kb = ReplyKeyboardMarkup([[tp] for tp in ulist] + [["üîô –ù–∞–∑–∞–¥"]], resize_keyboard=True)
            return await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –¢–ü –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:", reply_markup=kb)
        tp = ulist[0]
        data["tp"] = tp
        subset = found[found["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"]==tp]
        data["vl_df"]      = subset
        data["notify_res"] = subset.iloc[0]["–†–≠–°"]
        data["step"]       = "NOTIFY_VL"
        vls = subset["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –í–õ"].unique().tolist()
        kb  = ReplyKeyboardMarkup([[vl] for vl in vls] + [["üîô –ù–∞–∑–∞–¥"]], resize_keyboard=True)
        return await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –í–õ –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:", reply_markup=kb)

    # NOTIFY_DISAMB
    if step == "NOTIFY_DISAMB":
        found = data["amb_df_notify"]
        if text == "üîô –ù–∞–∑–∞–¥":
            data["step"] = "NOTIFY_AWAIT_TP"
            return await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –¢–ü –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:", reply_markup=kb_back)
        if text in found["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"].unique():
            data["tp"] = text
            subset = found[found["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –¢–ü"]==text]
            data["vl_df"]      = subset
            data["notify_res"] = subset.iloc[0]["–†–≠–°"]
            data["step"]       = "NOTIFY_VL"
            vls = subset["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –í–õ"].unique().tolist()
            kb  = ReplyKeyboardMarkup([[vl] for vl in vls] + [["üîô –ù–∞–∑–∞–¥"]], resize_keyboard=True)
            return await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –í–õ –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:", reply_markup=kb)

    # NOTIFY_VL
    if step == "NOTIFY_VL":
        subset = data["vl_df"]
        if text == "üîô –ù–∞–∑–∞–¥":
            data["step"] = "NOTIFY_AWAIT_TP"
            return await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –¢–ü –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:", reply_markup=kb_back)
        if text in subset["–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –í–õ"].unique():
            data["vl"]   = text
            data["step"] = "NOTIFY_GEO"
            return await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é:", reply_markup=kb_request_location)

    # –µ—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –ø–æ–¥–æ—à–ª–æ, —Å–±—Ä–æ—Å –≤ —Å—Ç–∞—Ä—Ç
    return await start_cmd(update, context)

# --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏ –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π ---
async def location_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if context.user_data.get("step") != "NOTIFY_GEO":
        return
    loc       = update.message.location
    tp        = context.user_data["tp"]
    vl        = context.user_data["vl"]
    res_tp    = context.user_data["notify_res"]
    sender    = context.user_data["name"]
    _,_,_,names,resp_map = load_zones()

    # –ø—Ä–∏–Ω–∏–º–∞—é—â–∏–µ ‚Äî —É –∫–æ–≥–æ –≤ –∫–æ–ª–æ–Ω–∫–µ F —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å res_tp
    recipients = [
        uid for uid, r in resp_map.items()
        if r.strip().lower() == res_tp.strip().lower()
    ]

    msg   = f"üîî –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç {sender}, {res_tp} –†–≠–°, {tp}, {vl} ‚Äì –ù–∞–π–¥–µ–Ω –±–µ–∑–¥–æ–≥–æ–≤–æ—Ä–Ω–æ–π –í–û–õ–°"
    log_f = NOTIFY_LOG_FILE_UG if context.user_data["net"]=="–†–æ—Å—Å–µ—Ç–∏ –Æ–ì" else NOTIFY_LOG_FILE_RK

    for cid in recipients:
        await context.bot.send_message(cid, msg)
        await context.bot.send_location(cid, loc.latitude, loc.longitude)
        await context.bot.send_message(
            cid,
            f"üìç –®–∏—Ä–æ—Ç–∞: {loc.latitude:.6f}, –î–æ–ª–≥–æ—Ç–∞: {loc.longitude:.6f}"
        )
        with open(log_f, "a", newline="", encoding="utf-8") as f:
            csv.writer(f).writerow([
                context.user_data["branch_user"],
                res_tp,
                update.effective_user.id,
                sender,
                cid,
                names.get(cid, ""),
                datetime.now(timezone.utc).isoformat(),
                f"{loc.latitude:.6f},{loc.longitude:.6f}"
            ])

    if recipients:
        names_list = [names[c] for c in recipients]
        await update.message.reply_text(
            f"‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {', '.join(names_list)}",
            reply_markup=kb_actions
        )
    else:
        await update.message.reply_text(
            f"‚ö† –û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π –Ω–∞ {res_tp} –†–≠–° –Ω–µ –Ω–∞–∑–Ω–∞—á–µ–Ω.",
            reply_markup=kb_actions
        )

    context.user_data["step"] = "BRANCH"

# --- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ –º–µ–Ω—é –ø–æ—Å–ª–µ —Å–ø—Ä–∞–≤–∫–∏ ---
async def restore_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    step     = context.user_data.get("step", "INIT")
    v        = context.user_data["vis_flag"]
    r        = context.user_data["res_user"]
    if step == "INIT":
        return await update.message.reply_text(
            "–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:", reply_markup=build_initial_kb(v, r)
        )
    if step == "REPORT_MENU":
        return await update.message.reply_text(
            "üìù –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –æ—Ç—á—ë—Ç–∞:", reply_markup=build_report_kb(v)
        )
    if step == "BRANCH":
        return await update.message.reply_text(
            "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=kb_actions
        )
    return await update.message.reply_text("üîô –ù–∞–∑–∞–¥", reply_markup=kb_back)

# --- –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —Ö–µ–Ω–¥–ª–µ—Ä–æ–≤ ---
application.add_handler(CommandHandler("start", start_cmd))
application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))
application.add_handler(MessageHandler(filters.LOCATION, location_handler))

# --- –ó–∞–ø—É—Å–∫ –≤–µ–±—Ö—É–∫–∞ ---
if __name__ == "__main__":
    if SELF_URL:
        threading.Thread(
            target=lambda: requests.get(f"{SELF_URL}/webhook"),
            daemon=True
        ).start()
    application.run_webhook(
        listen="0.0.0.0", port=PORT,
        url_path="webhook", webhook_url=f"{SELF_URL}/webhook"
    )
